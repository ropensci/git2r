---
title: "Data repository"
author: "Thierry Onkelinx"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data repository}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Rationale

In some cases we want to place data under version control. Data refers here to the information which is stored in a rectangular format. The columns define variables, while the rows represent observations. There is no information in neither the order of the columns nor the order of the rows. We assume that the data is available as an R `data.frame`.

Although git can store binary files, its real power and efficiency is with plain text files. R has several functions to read and write `data.frames` as plain text files. Main downside is the loss of metadata, especially in case of `factors`. A `factor` will be written as a `character` and hence lose all information on the levels. This can be important when the levels are a) not sorted alphabetically, b) not all levels have observations or c) the `factor` is ordered. Besides that, storing a `factor` as a `character` is not efficient.

Git stores the version history under the form of diffs: a list of lines which are deleted and a list of lines which are inserted at a specific line number in a file. We have to keep this in mind when storing data as plain text files in Git. The table below indicates the impact of changing the information content on the diff in Git. Note that changing observations requires a small diff, while changing variables results in a massive diff.

```{r echo = FALSE}
cases <- rbind(
    c("remove 1 observation", "remove 1 line"),
    c("add 1 observation", "add 1 line"),
    c("update 1 observation", "remove 1 line and add 1 line"),
    c("remove 1 variable", "remove all lines and add all lines"),
    c("add 1 variable", "remove all lines and add all lines")
)
colnames(cases) <- c("Change in data", "Git diff")
kable(cases, caption = "Changes in the information content of the data")
```

In the next table we show the effect on the diff when making changes in the data which don't change the information content of the data.

```{r echo = FALSE}
cases <- rbind(
    c("move 1 observation", "remove 1 line and add 1 line"),
    c("move 1 variable", "remove all lines and add all lines")
)
colnames(cases) <- c("Change in data", "Git diff")
kable(cases, caption = "Changes in the data without changing the information content")
```

So in order to use Git as a performant and efficient version control system for data, we need to make sure to store the metadata and keep the diffs as small as possible.

## Tools in `git2r`

### Data repository

A 'data repository' refers to a subdirectory within the root of an existing git repository. Create a `data_repository` object with `init()` or `repository()` and specify the subdirectory through the `project` argument. Most functions of the package handle a `data_repository` object in the same way as they handle a `git_repository` object. The main difference is that the working directory points to the subdirectory of the root, rather than the root of the git repository. You can create multiple data repositories within the same git repository.

```{r}
# Create a directory in tempdir
path <- tempfile(pattern = "git2r-")
dir.create(path)

library(git2r)
# inititialize a new git repository
repo <- init(path)
# use a data repository in an existing git repository
data_repo <- repository(path, project = "test")
```

```{r eval = FALSE}
# inititialize a new git repository and use a data repository within it
data_repo <- init(path, project = "test")
```

### Storing data

Use `write_delim_git()` to store a `data.frame` into the data repository. The function will separate the data and the metadata. The data is stored as a headerless, unquoted tab delimited file with ".tsv" extension and UTF-8 encoding. The metadata is stored in YAML format with ".yml" format. Therefore any extension given to the `file` will be stripped (with a warning).

The function will do a lot more preprocessing to the data in order to keep the file and the diff as small as possible. That is the reason why the data is stored headerless and unquoted. 

- `logical` is written as 0 (FALSE), 1 (TRUE) or NA to the data. The class is stored in the metadata.
- `integer` is written as is to the data. The class is stored in the metadata.
- `numeric` is written as is to the data. The class is stored in the metadata.
- `complex` is written as is to the data. The class is stored in the metadata.
- `character` is written as is and unquoted to the data. The class is stored in the metadata.
- `factor` is  stored as its indices in the data. The labels of levels are stored in the metadata.
- `POSIXct` is written as an integer to the data. The class and the origin are stored in the metadata.

```{r}
# Create dummy data
x <- data.frame(
    x = LETTERS,
    y = factor(
        sample(c("a", "b", NA), 26, replace = TRUE),
        levels = c("a", "b", "c")
    ),
    z = c(NA, 1:25),
    abc = c(rnorm(25), NA),
    xyz = complex(real = rnorm(26), imaginary = rnorm(26)),
    def = sample(c(TRUE, FALSE, NA), 26, replace = TRUE),
    timestamp = seq(
        as.POSIXct("2018-01-01"),
        as.POSIXct("2019-01-01"),
        length = 26
    ),
    stringsAsFactors = FALSE
)
str(x)
```

Another important part of the preprocessing is ordering both the variables and the observations. This is determined when the file is created and stored in the metadata. When the file is overwritten, the ordering is based on the existing metadata. Therefore it is important to think carefully about the ordering and make sure that it is how you want it to stay **before** you create your first commit. The ordering of the observations is specified through the `sorting` argument. It holds a vector of variable names which are used in the ordering. Make sure that you add enough sorting variables to avoid ties. `sorting` also defines the order of the variables. The order of the other variables is taken from the `data.frame`.

The data file (".tsv") and the metadata file (".yml") are automatically staged after writing. `write_delim_git()` returns the hashes of both the data file and the metadata file. The names of the vector contain the path of the files, relative to the root of the _git_ repository.

```{r}
status(data_repo)
write_delim_git(x = x, file = "my_data", repo = data_repo, sorting = c("y", "x"))
status(data_repo)
status(repo)
```

Overwriting data which has different metadata than the original data will throw an error because this can potentially lead to large diffs. Differences in metadata occur when:

- the sorting changes
- variables are added, removed or renamed
- the class of a variable changes
- the levels of a factor changes

However you can bypass this by using `override = TRUE`. This will completely ignore the existing metadata and create new metadata based on the new `data.frame`.

```{r error=TRUE}
y <- x
y$extra <- x$x
write_delim_git(y, file = "my_data", repo = data_repo, sorting = c("y", "x"))
write_delim_git(
    y, file = "my_data", repo = data_repo, sorting = c("y", "x"), 
    override = TRUE
)
```

### Reading data

Retrieving data is straight forward. Use `read_delim_git` and provide the `file` and the `repo`. The retrieved data is identical to the original data after applying the ordering of variables and observations.

```{r}
y_stored <- read_delim_git(file = "my_data", repo = data_repo)
str(y_stored)
y_sorted <- y[order(y$y, y$x), colnames(y_stored)]
rownames(y_sorted) <- NULL
stopifnot(all.equal(y_sorted, y_stored))
```

### Committing changes

Commit the changes using `commit()`

```{r}
write_delim_git(x, file = "sub/test", repo = data_repo, sorting = "x")
status(data_repo)
commit(data_repo, message = "Initial commit")
status(data_repo)
```

### Removing data

Data objects can be removed with `rm_file`. Provide the data repository to `repo` and the data object name to `path`.`path` can take multiple data objects.

```{r}
# remove a single data object
rm_file(repo = data_repo, path = "my_data")
status(data_repo)
# undo the remove by resetting to the last commit
reset(commits(data_repo)[[1]], "hard")
status(data_repo)
# remove multiple data objects
rm_file(repo = data_repo, path = c("my_data", "sub/test"))
status(data_repo)
```

Note that this will remove both the data and the metadata.

In case of a data repository, there are three options for `path`:

- a vector of file names as used in `write_delim_git}`. This will remove all associated `.tsv` and `.yml` files.
- `".tsv"` will remove ALL `.tsv` files.
- `".yml"` will remove all `.yml` files which have no associated `.tsv` file.

In case you want to update the current data, it is better to overwrite the data than first delete it and then write it. Sometime you want to write a bunch of data object to the data repository and you cannot guarantee that all data objects will remain after the update. The workflow below is intended for such case.

1. use `path = ".tsv"` in `rm_file()` to remove **all** ".tsv" in the data repository
1. use `write_delim_git()` to write all data objects. Since the ".yml" are still present, any existing metadata will be used.
1. use `path = ".yml"` in `rm_file()` to remove **any** ".yml" which have no associated ".tsv"
1. `commit()` the changes

```{r}
# undo the remove by resetting to the last commit
reset(commits(data_repo)[[1]], "hard")
status(data_repo)
rm_file(data_repo, ".tsv")
status(data_repo)
write_delim_git(x, file = "sub/test", repo = data_repo, sorting = "x")
status(data_repo)
rm_file(data_repo, ".yml")
status(data_repo)
commit(data_repo, "Automated update")
```

